#!/usr/bin/env scheme-r7rs
;; Copyright 2019 Alexander Mohn
;; This script is released under the GNU General Public License v3.
;; See the LICENSE file in the accompanying directory for more details.

;; This scheme script modifies the output of cyclone -d to include additional
;; libraries necessary to link the program, then runs that modified output.
;;; Imports ;;;
(import (scheme base)
	(scheme write)
	(scheme file)
	(scheme cyclone match)
	(srfi 27)
	; Because of how scheme-r7rs is implemented on my system,
	; this file is called via icyc -s $tmpfile$ args. This library
	; lets the script grab the actual args, without icyc -s $tmpfile$
	(lib args))

;;; Procedures ;;;
;; Usage Hint
(define (usage)
  (newline)
  (display "Usage: cyclone_link [FILENAME] [OPTIONS]")
  (newline)
  (display "Compile a Scheme program that requires linking additional")
  (newline)
  (display "C libraries beyond those linked by Cyclone Scheme.")
  (newline)
  (newline)
  (display "Options:")
  (newline)
  (newline)
  (display "-f file                 Specify filename with option instead ")
  (display "of with position")
  (newline)
  (display "-l library [library]*   Additional libraries to link")
  (newline)
  (display "--help-me               Display usage information")
  (newline)
  (newline)
  (exit))

;; Display if there's invalid usage
(define (invalid-usage)
  (display "Invalid usage. Help displayed below:")
  (newline)
  (usage))

;; Actual compilation procedure
(define (compile-with-linked-libs prog libs)
  (display "Compiling file: ")
  (display prog)
  (newline)
  (display "With linked libraries: ")
  (display libs)
  (newline)
  (let* ((libs (map to-gcc-flag libs))
	 (tmp (mktemp))
	 (cyclone-cmd (string-append "cyclone -d " prog))) 
    (display "Calling cyclone.")
    (newline)
    ; Redirect suggested compiler commands to tempfile
    (system (string-append cyclone-cmd ">" tmp))
    ; Read suggested commands from tempfile and append appropriate linking flags
    (call-with-input-file tmp
      (lambda (f)
	(let* ((cmd-1 (read-line f))
	       (cmd-2 (apply string-append
			     (cons (read-line f) libs))))
	  (display "Calling gcc with: ")
	  (display cmd-1)
	  (newline)
	  (system cmd-1)
	  (display "Calling gcc with: ")
	  (display cmd-2)
	  (newline)
	  (system (apply string-append (cons cmd-2 libs))))))
    (system (string-append "rm " tmp))    ; cleanup
    (exit)))

;; Convert a string into a gcc -l flag
(define (to-gcc-flag lib)
  (string-append " -l" lib))

;; Generate a random alphanumeric char
(define (random-char)
  (let ((num (random-integer 62))
	(str "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"))
    (string-ref str num)))

;; Generate a temporary filename similar to that generated by the
;; mktemp shell command
(define (mktemp)
  (string-append "/tmp/tmp." (list->string (map (lambda (x) (random-char))
						(make-list 10)))))

;;; Macro ;;;
;; Syntatic sugar to match several different patterns where the bindings may
;; or may not be created by match-let
(define-syntax match-one-of-let
  (syntax-rules ()
    ((match-one-of-let ((idents ...)      ; bind these vars
		        (patterns ...)    ; matched using one of these patterns
		        expr)             ; against this expression
		       bodies ...)        ; run these bodies in scope of vars
     ; Be sure to capture all vars, even if not matched by the patterns
     (let ((idents '()) ...)
       (match-let (((or patterns ...) expr)) bodies ...)))))

;;; Script ;;;
;; Parses the arguments via pattern-matching
(let ((args (get-args)))
  (if (null? args)
      (usage)
      (match-one-of-let
       ((prog libs help err)
	((and (help) ("--help-me"))       ; bind "--help-me" to help
	 ("-f" prog "-l" libs ..1)
	 ("-l" libs ... "-f" prog)
	 ("-f" prog)
	 (prog "-l" libs ..1)
	 (prog)
	 (err ...))
	args)
       (cond ((not (null? help)) (usage))
	     ((not (null? err)) (invalid-usage))
	     (else (compile-with-linked-libs prog libs))))))
